const MyActivityService = require('../services/myActivityService');
const MyActivityHelpers = require('../services/myActivityHelpers');
const MyActivityFormatters = require('../utils/myActivityFormatters');
const Task = require('../models/Task');
const WorkTask = require('../models/WorkTask');
const QualityControlEvaluation = require('../models/QualityControlEvaluation');
const HRScore = require('../models/HRScore');
const KalipDegisimEvaluation = require('../models/KalipDegisimEvaluation');
const BonusEvaluation = require('../models/BonusEvaluation');
const User = require('../models/User');

/**
 * MyActivity Controller Layer
 * Handles HTTP requests and responses for MyActivity routes
 */
class MyActivityController {
  /**
   * Test endpoint
   */
  static testEndpoint(req, res) {
    try {
      console.log('üîç Test route √ßalƒ±≈üƒ±yor...');
      console.log('User ID:', req.user._id);
      console.log('User ad:', req.user.ad);
      console.log('User roller:', req.user.roller?.length || 0);

      res.json({
        message: 'Test ba≈üarƒ±lƒ±',
        user: {
          id: req.user._id,
          ad: req.user.ad,
          soyad: req.user.soyad,
          rollerSayisi: req.user.roller?.length || 0,
        },
      });
    } catch (error) {
      console.error('‚ùå Test route hatasƒ±:', error.message);
      console.error('‚ùå Stack:', error.stack);
      res.status(500).json({ message: 'Test hatasƒ±: ' + error.message });
    }
  }

  /**
   * Get user activity summary
   */
  static async getSummary(req, res) {
    try {
      console.log('üîç Summary endpoint ba≈üladƒ±');
      console.log('User:', req.user?.ad, req.user?.soyad);
      console.log('User ID:', req.user?._id);

      const { days = 30 } = req.query;
      const userId = req.user._id;

      if (!userId) {
        console.error('‚ùå User ID bulunamadƒ±');
        return res.status(400).json({ message: 'User ID gerekli' });
      }

      console.log(
        `üìä ${req.user.ad} ${req.user.soyad} i√ßin aktivite √∂zeti hesaplanƒ±yor...`,
      );

      // Get raw data from service
      const data = await MyActivityService.getUserSummary(userId, days);

      // ‚úÖ DEBUG: Control scores debug
      console.log('üîç Raw control scores count:', data.controlScores.length);
      if (data.controlScores.length > 0) {
        console.log(
          'üîç Control scores details:',
          data.controlScores.map(score => ({
            gorevTipi: score.gorevTipi,
            puan: score.kontrolPuani,
            tarih: score.puanlamaTarihi,
            puanlanan: score.puanlananKullanici,
          })),
        );
      }

      // Calculate scores by category
      const scoresByCategory = MyActivityService.calculateScoresByCategory(
        data,
        userId,
      );

      // Format general statistics
      const genelIstatistikler = MyActivityFormatters.formatGeneralStats(
        data,
        scoresByCategory,
        days,
      );

      // Response
      const summary = {
        kullanici: {
          id: req.user._id,
          ad: req.user.ad,
          soyad: req.user.soyad,
          roller: req.user.roller,
        },
        tarihAraligi: {
          baslangic: data.dateRange.startDate,
          bitis: data.dateRange.endDate,
          gunSayisi: parseInt(days),
        },
        genelIstatistikler,
        kategorilerePuanlar: scoresByCategory,
        checklistGorevleri: data.checklistTasks.length,
        iseBagliGorevleri: data.workTasks.length,
        kaliteKontrolDegerlendirmeleri: data.qualityEvaluations.length,
        ikDegerlendirmeleri: data.hrScores.length,
        bonusDegerlendirmeleri: data.bonusEvaluations.length,
        kalipDegisimDegerlendirmeleri: data.kalipDegisimEvaluations.length,
        kontrolPuanlari: data.controlScores.length,
      };

      console.log(
        `‚úÖ Aktivite √∂zeti hazƒ±rlandƒ± - Toplam: ${genelIstatistikler.toplamGorevSayisi} g√∂rev, ${genelIstatistikler.toplamPuan} puan`,
      );
      res.json(summary);
    } catch (error) {
      console.error('‚ùå Aktivite √∂zeti hatasƒ±:', error.message);
      res.status(500).json({ message: 'Sunucu hatasƒ±' });
    }
  }

  /**
   * Get detailed activity list
   */
  static async getDetailed(req, res) {
    try {
      const userId = req.user._id;
      const filters = req.query;

      console.log(
        `üìã ${req.user.ad} ${req.user.soyad} i√ßin detaylƒ± aktivite listesi getiriliyor...`,
      );

      // Get activities data
      const activityData = await MyActivityHelpers.getDetailedActivities(
        userId,
        filters,
      );

      console.log('üìä Aktivite verileri:', {
        checklistTasks: activityData.checklistTasks.length,
        workTasks: activityData.workTasks.length,
        qualityEvaluations: activityData.qualityEvaluations.length,
        hrScores: activityData.hrScores.length,
        bonusEvaluations: activityData.bonusEvaluations?.length || 0,
        controlPendingTasks: activityData.controlPendingTasks?.length || 0,
        controlScores: activityData.controlScores?.length || 0,
        kalipDegisimEvaluations:
          activityData.kalipDegisimEvaluations?.length || 0,
      });

      // Format activities - T√ºm aktivite tiplerini dahil et
      const allActivities = MyActivityFormatters.formatDetailedActivities(
        activityData.checklistTasks,
        activityData.workTasks,
        activityData.qualityEvaluations,
        activityData.hrScores,
        activityData.bonusEvaluations || [],
        activityData.controlPendingTasks || [],
        activityData.controlScores || [],
        activityData.kalipDegisimEvaluations || [],
        userId, // User context for buddy detection
      );

      // Calculate pagination - T√ºm aktivite tiplerini dahil et
      const toplamKayit =
        activityData.totalChecklistTasks +
        activityData.totalWorkTasks +
        activityData.totalQualityEvaluations +
        activityData.totalHRScores +
        (activityData.totalBonusEvaluations || 0) +
        (activityData.totalControlPendingTasks || 0) +
        (activityData.totalControlScores || 0) +
        (activityData.totalKalipDegisimEvaluations || 0);

      // Apply pagination to combined activities
      const skip =
        (activityData.pagination.pageNum - 1) *
        activityData.pagination.limitNum;
      const paginatedActivities = allActivities.slice(
        skip,
        skip + activityData.pagination.limitNum,
      );

      const toplamSayfa = Math.ceil(
        toplamKayit / activityData.pagination.limitNum,
      );

      console.log(
        `‚úÖ ${allActivities.length} toplam aktivite, ${paginatedActivities.length} g√∂steriliyor`,
      );

      res.json({
        activities: paginatedActivities,
        sayfalama: {
          mevcutSayfa: activityData.pagination.pageNum,
          toplamSayfa,
          toplamKayit,
          sayfaBoyutu: activityData.pagination.limitNum,
        },
        aktiviteTipleri: {
          checklistTasks: activityData.totalChecklistTasks,
          workTasks: activityData.totalWorkTasks,
          qualityEvaluations: activityData.totalQualityEvaluations,
          hrScores: activityData.totalHRScores,
          bonusEvaluations: activityData.totalBonusEvaluations || 0,
          controlPendingTasks: activityData.totalControlPendingTasks || 0,
          controlScores: activityData.totalControlScores || 0,
        },
      });
    } catch (error) {
      console.error('‚ùå Detaylƒ± aktivite hatasƒ±:', error.message);
      console.error('‚ùå Stack:', error.stack);
      res.status(500).json({ message: 'Sunucu hatasƒ±' });
    }
  }

  /**
   * Get score details
   */
  static async getScoresDetail(req, res) {
    try {
      const userId = req.user._id;
      const filters = req.query;

      console.log(
        `üèÜ ${req.user.ad} ${req.user.soyad} i√ßin puanlama detaylarƒ± getiriliyor...`,
      );

      // Get score data
      const scoreData = await MyActivityHelpers.getScoreDetails(
        userId,
        filters,
      );

      // Format score details
      const scoreDetails = MyActivityFormatters.formatScoreDetails(
        scoreData,
        scoreData.dateRange.startDate,
        scoreData.dateRange.endDate,
      );

      // Apply pagination
      const skip =
        (scoreData.pagination.pageNum - 1) * scoreData.pagination.limitNum;
      const toplamKayit = scoreDetails.length;
      const toplamSayfa = Math.ceil(
        toplamKayit / scoreData.pagination.limitNum,
      );
      const paginatedScoreDetails = scoreDetails.slice(
        skip,
        skip + scoreData.pagination.limitNum,
      );

      console.log(
        `‚úÖ ${scoreDetails.length} puanlama detayƒ± hazƒ±rlandƒ±, ${paginatedScoreDetails.length} g√∂steriliyor`,
      );

      res.json({
        scoreDetails: paginatedScoreDetails,
        sayfalama: {
          mevcutSayfa: scoreData.pagination.pageNum,
          toplamSayfa,
          toplamKayit,
          sayfaBoyutu: scoreData.pagination.limitNum,
        },
        istatistikler: {
          toplamPuanliGorev: toplamKayit,
          sonGunler: parseInt(filters.days || 30),
          tarihAraligi: {
            baslangic: scoreData.dateRange.startDate,
            bitis: scoreData.dateRange.endDate,
          },
        },
      });
    } catch (error) {
      console.error('‚ùå Puanlama detaylarƒ± hatasƒ±:', error.message);
      console.error('‚ùå Stack trace:', error.stack);
      res.status(500).json({
        message: 'Sunucu hatasƒ±',
        error:
          process.env.NODE_ENV === 'development'
            ? error.message
            : 'Sunucu hatasƒ±',
      });
    }
  }

  /**
   * Get task details by ID
   */
  static async getTaskDetails(req, res) {
    try {
      const taskId = req.params.id;
      console.log('üîç Task details isteniyor:', taskId);
      console.log('üìù Task ID analizi:', {
        length: taskId.length,
        startsWithHR: taskId.startsWith('hr_'),
        isHRChecklist: taskId.startsWith('hr_checklist_'),
        isHRMesai: taskId.startsWith('hr_mesai_'),
        isHRDevamsizlik: taskId.startsWith('hr_devamsizlik_'),
        isKalipDegisim: taskId.startsWith('kalip_degisim_'),
        isBonusEval: taskId.startsWith('bonus_eval_'),
      });

      // Check if it's a Kalƒ±p Deƒüi≈üim evaluation
      if (
        taskId.startsWith('kalip_degisim_main_') ||
        taskId.startsWith('kalip_degisim_buddy_')
      ) {
        console.log('üîß Kalƒ±p deƒüi≈üim deƒüerlendirmesi tespit edildi');
        const actualId = taskId
          .replace('kalip_degisim_main_', '')
          .replace('kalip_degisim_buddy_', '');
        const isMainWorker = taskId.startsWith('kalip_degisim_main_');

        console.log(
          'üìã Kalƒ±p deƒüi≈üim ID:',
          actualId,
          'Ana √ßalƒ±≈üan:',
          isMainWorker,
        );

        const kalipDegisimEvaluation = await KalipDegisimEvaluation.findById(
          actualId,
        )
          .populate('checklistTemplate', 'ad aciklama maddeler')
          .populate('workTask', 'makina indirilenKalip baglananHamade')
          .populate('degerlendiren', 'ad soyad')
          .populate('anaCalisan', 'ad soyad kullaniciAdi')
          .populate('buddyCalisan', 'ad soyad kullaniciAdi');

        if (kalipDegisimEvaluation) {
          console.log('‚úÖ Kalƒ±p deƒüi≈üim deƒüerlendirmesi bulundu');
          console.log('üîç Debug - Kalƒ±p deƒüi≈üim evaluation verileri:', {
            id: kalipDegisimEvaluation._id,
            checklistTemplate: kalipDegisimEvaluation.checklistTemplate?.ad,
            maddeleSayisi: kalipDegisimEvaluation.maddeler?.length || 0,
            templateMaddeleSayisi:
              kalipDegisimEvaluation.checklistTemplate?.maddeler?.length || 0,
            anaCalƒ±sanPuan: kalipDegisimEvaluation.anaCalƒ±sanToplamPuan,
            buddyPuan: kalipDegisimEvaluation.buddyToplamPuan,
            maxPuan: kalipDegisimEvaluation.maxToplamPuan,
          });

          // Maddeler kontrol√º - hangisini kullanacaƒüƒ±z?
          const maddelerKaynak =
            kalipDegisimEvaluation.maddeler?.length > 0
              ? 'evaluation.maddeler'
              : 'template.maddeler';
          console.log('üîç Maddeler kaynaƒüƒ±:', maddelerKaynak);

          if (kalipDegisimEvaluation.maddeler?.length > 0) {
            console.log(
              'üîç Evaluation maddeler (ilk 3):',
              kalipDegisimEvaluation.maddeler.slice(0, 3).map(m => ({
                baslik: m.baslik,
                puan: m.puan,
                maksimumPuan: m.maksimumPuan,
              })),
            );
          }

          if (kalipDegisimEvaluation.checklistTemplate?.maddeler?.length > 0) {
            console.log(
              'üîç Template maddeler (ilk 3):',
              kalipDegisimEvaluation.checklistTemplate.maddeler
                .slice(0, 3)
                .map(m => ({
                  baslik: m.baslik,
                  maksimumPuan: m.maksimumPuan,
                })),
            );
          }

          // Field mapping ile doƒüru response d√∂nd√ºr
          const mappedMaddeler = (kalipDegisimEvaluation.maddeler || []).map(
            madde => ({
              baslik: madde.soru, // soru ‚Üí baslik
              maksimumPuan: madde.maxPuan, // maxPuan ‚Üí maksimumPuan
              puan: madde.verilenPuan, // verilenPuan ‚Üí puan
              yorum: madde.yorum || '',
              resimUrl: madde.resimUrl || '',
              maddeId: madde.maddeId,
            }),
          );

          console.log(
            'üîß Field mapping sonrasƒ± maddeler (ilk 3):',
            mappedMaddeler.slice(0, 3).map(m => ({
              baslik: m.baslik,
              puan: m.puan,
              maksimumPuan: m.maksimumPuan,
            })),
          );

          return res.json({
            tip: 'kalip_degisim',
            checklistAdi:
              kalipDegisimEvaluation.checklistTemplate?.ad || 'Kalƒ±p Deƒüi≈üim',
            kategori: isMainWorker
              ? 'Kalƒ±p Deƒüi≈üim - Ana √áalƒ±≈üan'
              : 'Kalƒ±p Deƒüi≈üim - Buddy',
            tarih: kalipDegisimEvaluation.degerlendirmeTarihi,
            puan: isMainWorker
              ? kalipDegisimEvaluation.anaCalƒ±sanToplamPuan
              : kalipDegisimEvaluation.buddyToplamPuan,
            maksimumPuan: kalipDegisimEvaluation.maxToplamPuan || 100,
            maddeler: mappedMaddeler, // Mapped maddeler kullan
            degerlendiren: kalipDegisimEvaluation.degerlendiren,
            rol: isMainWorker ? 'Ana √áalƒ±≈üan' : 'Buddy',
            workTask: kalipDegisimEvaluation.workTask,
          });
        } else {
          console.log('‚ùå Kalƒ±p deƒüi≈üim deƒüerlendirmesi bulunamadƒ±:', actualId);
        }
      }

      // Check if it's a Bonus evaluation
      if (taskId.startsWith('bonus_eval_')) {
        console.log('üéÅ Bonus deƒüerlendirmesi tespit edildi');
        const actualId = taskId.replace('bonus_eval_', '');

        console.log('üìã Bonus evaluation ID:', actualId);

        const bonusEvaluation = await BonusEvaluation.findById(actualId)
          .populate('sablon', 'ad aciklama bonusKategorisi')
          .populate('degerlendirenKullanici', 'ad soyad')
          .populate('departman', 'ad');

        if (bonusEvaluation) {
          console.log('‚úÖ Bonus deƒüerlendirmesi bulundu');
          // Basit bir response d√∂nd√ºr ≈üimdilik
          return res.json({
            tip: 'bonus_evaluation',
            checklistAdi: bonusEvaluation.sablon?.ad || 'Bonus Deƒüerlendirmesi',
            kategori: `Bonus - ${bonusEvaluation.sablon?.bonusKategorisi || 'Genel'}`,
            tarih: bonusEvaluation.degerlendirmeTarihi,
            puan: bonusEvaluation.toplamPuan || 0,
            maksimumPuan: bonusEvaluation.sablon?.maksimumPuan || 100,
            maddeler: bonusEvaluation.puanlamalar || [],
            degerlendiren: bonusEvaluation.degerlendirenKullanici,
            bonusKategorisi: bonusEvaluation.sablon?.bonusKategorisi,
            departman: bonusEvaluation.departman,
          });
        } else {
          console.log('‚ùå Bonus deƒüerlendirmesi bulunamadƒ±:', actualId);
        }
      }

      // Check if it's an HR evaluation
      if (
        taskId.startsWith('hr_checklist_') ||
        taskId.startsWith('hr_mesai_') ||
        taskId.startsWith('hr_devamsizlik_')
      ) {
        console.log('üè• ƒ∞K deƒüerlendirmesi tespit edildi');
        const taskDetails = await MyActivityController.getHRTaskDetails(taskId);
        console.log('‚úÖ ƒ∞K task details ba≈üarƒ±yla d√∂nd√ºr√ºl√ºyor');
        return res.json(taskDetails);
      }

      // Check if it's a Quality Control evaluation
      if (taskId.length === 24 && !taskId.startsWith('hr_')) {
        console.log('üî¨ Kalite kontrol deƒüerlendirmesi aranƒ±yor:', taskId);

        const qualityEvaluation = await QualityControlEvaluation.findById(
          taskId,
        )
          .populate('sablon', 'ad aciklama kriterler')
          .populate('degerlendirenKullanici', 'ad soyad')
          .populate('makina', 'ad envanterKodu')
          .populate('kalip', 'ad envanterKodu');

        if (qualityEvaluation) {
          console.log('‚úÖ Kalite kontrol deƒüerlendirmesi bulundu');
          const taskDetails =
            MyActivityFormatters.formatQualityEvaluationDetails(
              qualityEvaluation,
            );
          return res.json(taskDetails);
        } else {
          console.log('‚ùå Kalite kontrol deƒüerlendirmesi bulunamadƒ±');
        }
      }

      // Try to find as WorkTask first
      console.log('üîß WorkTask olarak aranƒ±yor...');
      const workTask = await WorkTask.findById(taskId)
        .populate('kullanici', 'ad soyad kullaniciAdi')
        .populate('checklist', 'ad kategori aciklama maddeler')
        .populate('makina', 'ad makinaNo envanterKodu')
        .populate('indirilenKalip', 'envanterKodu ad dinamikAlanlar')
        .populate('baglananHamade', 'envanterKodu ad dinamikAlanlar')
        .populate('onaylayanKullanici', 'ad soyad');

      if (workTask) {
        console.log('‚úÖ WorkTask bulundu');
        const taskDetails =
          MyActivityFormatters.formatWorkTaskDetails(workTask);
        console.log(
          `‚úÖ WorkTask detaylarƒ± hazƒ±rlandƒ± - ${taskDetails.checklistAdi} - ${taskDetails.maddeler.length} madde`,
        );
        return res.json(taskDetails);
      }

      // Normal task details
      console.log('üìã Normal Task olarak aranƒ±yor...');
      const task = await Task.findById(taskId)
        .populate('kullanici', 'ad soyad kullaniciAdi')
        .populate('checklist', 'ad kategori aciklama maddeler')
        .populate('makina', 'ad makinaNo envanterKodu')
        .populate('onaylayan', 'ad soyad')
        .populate('kontroleden', 'ad soyad');

      if (!task) {
        console.log('‚ùå Hi√ßbir yerde task bulunamadƒ±:', taskId);
        return res.status(404).json({ message: 'G√∂rev bulunamadƒ±' });
      }

      console.log('‚úÖ Normal Task bulundu');
      const taskDetails = MyActivityFormatters.formatTaskDetails(task);

      console.log(
        `‚úÖ ${taskDetails.checklistAdi} g√∂rev detaylarƒ± hazƒ±rlandƒ± - ${taskDetails.maddeler.length} madde`,
      );

      res.json(taskDetails);
    } catch (error) {
      console.error('‚ùå G√∂rev detaylarƒ± hatasƒ±:', error.message);
      console.error('‚ùå Error stack:', error.stack);
      console.error('‚ùå Error details:', {
        name: error.name,
        message: error.message,
        stack: error.stack,
      });
      res.status(500).json({
        message: 'Sunucu hatasƒ±',
        error:
          process.env.NODE_ENV === 'development'
            ? error.message
            : 'Sunucu hatasƒ±',
        details:
          process.env.NODE_ENV === 'development'
            ? {
              taskId: req.params.id,
              errorName: error.name,
              errorMessage: error.message,
            }
            : undefined,
      });
    }
  }

  /**
   * Get HR task details (helper method)
   */
  static async getHRTaskDetails(taskId) {
    try {
      console.log('üîç ƒ∞K task details isteniyor:', taskId);
      console.log('üìè Task ID uzunluƒüu:', taskId.length);

      const parts = taskId.split('_');
      console.log('üîß Split sonucu:', parts);
      console.log('üîß Parts sayƒ±sƒ±:', parts.length);

      if (parts.length < 4) {
        console.error('‚ùå Ge√ßersiz task ID formatƒ±:', taskId);
        throw new Error('Ge√ßersiz task ID formatƒ±');
      }

      const [, type, hrScoreId, subItemId] = parts;

      console.log('üìã Parse edilen bilgiler:', { type, hrScoreId, subItemId });
      console.log('üìä ID uzunluklarƒ±:', {
        type: type?.length,
        hrScoreId: hrScoreId?.length,
        subItemId: subItemId?.length,
      });

      // MongoDB ObjectID validation
      if (!hrScoreId || hrScoreId.length !== 24) {
        console.error('‚ùå Ge√ßersiz hrScoreId:', hrScoreId);
        throw new Error('Ge√ßersiz HR Score ID');
      }

      if (!subItemId || subItemId.length !== 24) {
        console.error('‚ùå Ge√ßersiz subItemId:', subItemId);
        throw new Error('Ge√ßersiz Sub Item ID');
      }

      const hrScore = await HRScore.findById(hrScoreId).populate(
        'checklistPuanlari.sablon',
        'ad aciklama maddeler',
      );

      if (!hrScore) {
        console.error('‚ùå ƒ∞K Score bulunamadƒ±:', hrScoreId);
        throw new Error('ƒ∞K deƒüerlendirmesi bulunamadƒ±');
      }

      console.log('‚úÖ ƒ∞K Score bulundu, alt veri aranƒ±yor...');
      console.log('üìä HR Score i√ßeriƒüi:', {
        checklistCount: hrScore.checklistPuanlari?.length || 0,
        mesaiCount: hrScore.mesaiKayitlari?.length || 0,
        devamsizlikCount: hrScore.devamsizlikKayitlari?.length || 0,
      });

      // Mevcut ID'leri listele
      if (hrScore.checklistPuanlari?.length > 0) {
        console.log(
          'üìã Mevcut checklist ID\'leri:',
          hrScore.checklistPuanlari.map(p => p._id.toString()),
        );
      }

      let evaluation = null;

      if (type === 'checklist') {
        evaluation = hrScore.checklistPuanlari.find(
          p => p._id.toString() === subItemId,
        );
        console.log(
          'üîç Checklist arama sonucu:',
          evaluation ? 'Bulundu' : 'Bulunamadƒ±',
        );
        if (evaluation) {
          console.log('‚úÖ Bulunan evaluation:', {
            id: evaluation._id,
            sablonId: evaluation.sablon?._id,
            tarih: evaluation.tarih,
            maddePuan: evaluation.madde?.puan,
            detaylarSayisi: evaluation.madde?.detaylar?.length || 0,
          });
        }
      } else if (type === 'mesai') {
        evaluation = hrScore.mesaiKayitlari.find(
          m => m._id.toString() === subItemId,
        );
        console.log(
          'üîç Mesai arama sonucu:',
          evaluation ? 'Bulundu' : 'Bulunamadƒ±',
        );
      } else if (type === 'devamsizlik') {
        evaluation = hrScore.devamsizlikKayitlari.find(
          d => d._id.toString() === subItemId,
        );
        console.log(
          'üîç Devamsƒ±zlƒ±k arama sonucu:',
          evaluation ? 'Bulundu' : 'Bulunamadƒ±',
        );
      }

      if (!evaluation) {
        console.error('‚ùå ƒ∞K deƒüerlendirmesi bulunamadƒ±');
        console.log('üéØ Aranan subItemId:', subItemId);
        throw new Error('ƒ∞K deƒüerlendirmesi bulunamadƒ±');
      }

      console.log('‚úÖ ƒ∞K deƒüerlendirmesi bulundu, formatlanƒ±yor...');
      const formattedData = MyActivityFormatters.formatHRTaskDetails(
        taskId,
        type,
        evaluation,
      );
      console.log('‚úÖ Formatlanmƒ±≈ü veri hazƒ±r:', {
        id: formattedData.id,
        checklistAdi: formattedData.checklistAdi,
        maddelerSayisi: formattedData.maddeler?.length || 0,
      });

      return formattedData;
    } catch (error) {
      console.error('‚ùå ƒ∞K task details hatasƒ±:', error.message);
      console.error('‚ùå Error stack:', error.stack);
      throw error;
    }
  }

  /**
   * Get daily performance data
   */
  static async getDailyPerformance(req, res) {
    try {
      const { days = 30 } = req.query;
      const userId = req.user._id;

      console.log(
        `üìà ${req.user.ad} ${req.user.soyad} i√ßin g√ºnl√ºk performans verileri hesaplanƒ±yor...`,
      );

      const performanceData = await MyActivityHelpers.getDailyPerformance(
        userId,
        days,
      );

      res.json(performanceData);
    } catch (error) {
      console.error('‚ùå G√ºnl√ºk performans hatasƒ±:', error.message);
      res.status(500).json({ message: 'Sunucu hatasƒ±' });
    }
  }

  /**
   * Debug endpoint
   */
  static debugUser(req, res) {
    try {
      console.log('üêõ Debug endpoint √ßaƒürƒ±ldƒ±');
      console.log('User:', req.user);

      res.json({
        message: 'User authenticated successfully',
        user: {
          id: req.user._id,
          ad: req.user.ad,
          soyad: req.user.soyad,
          kullaniciAdi: req.user.kullaniciAdi,
        },
      });
    } catch (error) {
      console.error('Debug endpoint hatasƒ±:', error);
      res.status(500).json({ message: 'Debug hatasƒ±' });
    }
  }

  /**
   * Get role-based ranking by scores
   */
  static async getRanking(req, res) {
    try {
      const currentUser = req.user;
      const { days = 30 } = req.query;

      console.log(
        `üèÜ ${currentUser.ad} ${currentUser.soyad} i√ßin rol bazlƒ± sƒ±ralama hesaplanƒ±yor...`,
      );

      // Get users with same role
      const sameRoleUsers = await User.find({
        roller: { $in: currentUser.roller },
        aktif: true,
      }).select('ad soyad kullaniciAdi roller');

      console.log(
        `üìä ${currentUser.roller} rol√º i√ßin ${sameRoleUsers.length} kullanƒ±cƒ± bulundu`,
      );

      // Calculate scores for each user
      const rankings = [];
      const userPromises = sameRoleUsers.map(async user => {
        try {
          // Get user summary data
          const userData = await MyActivityService.getUserSummary(
            user._id,
            days,
          );
          const scoresByCategory =
            MyActivityService.calculateScoresByCategory(userData);

          // Calculate total score
          const totalScore = Object.values(scoresByCategory).reduce(
            (sum, score) => sum + score,
            0,
          );
          const totalTasks =
            userData.checklistTasks.length +
            userData.workTasks.length +
            userData.qualityEvaluations.length +
            userData.hrScores.length;

          return {
            kullanici: {
              id: user._id,
              ad: user.ad,
              soyad: user.soyad,
              kullaniciAdi: user.kullaniciAdi,
              isCurrentUser: user._id.toString() === currentUser._id.toString(),
            },
            toplamPuan: totalScore,
            toplamGorev: totalTasks,
            kategorilerePuanlar: scoresByCategory,
            ortalamaPuan:
              totalTasks > 0 ? (totalScore / totalTasks).toFixed(1) : 0,
          };
        } catch (userError) {
          console.log(
            `‚ö†Ô∏è ${user.ad} ${user.soyad} i√ßin puan hesaplanamadƒ±:`,
            userError.message,
          );
          // Add user with 0 score if calculation fails
          return {
            kullanici: {
              id: user._id,
              ad: user.ad,
              soyad: user.soyad,
              kullaniciAdi: user.kullaniciAdi,
              isCurrentUser: user._id.toString() === currentUser._id.toString(),
            },
            toplamPuan: 0,
            toplamGorev: 0,
            kategorilerePuanlar: {},
            ortalamaPuan: 0,
          };
        }
      });

      const rankingResults = await Promise.all(userPromises);
      rankings.push(...rankingResults);

      // Sort by total score (descending)
      rankings.sort((a, b) => b.toplamPuan - a.toplamPuan);

      // Add rank numbers
      rankings.forEach((ranking, index) => {
        ranking.sira = index + 1;
      });

      // Find current user's ranking
      const currentUserRanking = rankings.find(r => r.kullanici.isCurrentUser);

      console.log(
        `‚úÖ Sƒ±ralama hazƒ±rlandƒ± - ${rankings.length} kullanƒ±cƒ±, mevcut kullanƒ±cƒ± ${currentUserRanking?.sira || 'N/A'}. sƒ±rada`,
      );

      res.json({
        siralamalar: rankings,
        mevcutKullanici: currentUserRanking,
        toplamKullanici: rankings.length,
        tarihAraligi: {
          gunSayisi: parseInt(days),
          baslangic: new Date(Date.now() - days * 24 * 60 * 60 * 1000)
            .toISOString()
            .split('T')[0],
          bitis: new Date().toISOString().split('T')[0],
        },
      });
    } catch (error) {
      console.error('‚ùå Ranking hatasƒ±:', error.message);
      console.error('‚ùå Stack trace:', error.stack);
      res.status(500).json({
        message: 'Sunucu hatasƒ±',
        error:
          process.env.NODE_ENV === 'development'
            ? error.message
            : 'Sunucu hatasƒ±',
      });
    }
  }

  /**
   * Get detailed score breakdown with filters
   */
  static async getScoreBreakdown(req, res) {
    try {
      const userId = req.user._id;
      const filters = req.query;

      console.log(
        `üìä ${req.user.ad} ${req.user.soyad} i√ßin puan breakdown getiriliyor...`,
      );

      // Get score breakdown data
      const breakdownData = await MyActivityHelpers.getScoreBreakdown(
        userId,
        filters,
      );

      // Format breakdown details
      const scoreBreakdown =
        MyActivityFormatters.formatScoreBreakdown(breakdownData);

      // Calculate statistics
      const stats = {
        toplamGorev: scoreBreakdown.length,
        toplamPuan: scoreBreakdown.reduce(
          (sum, item) => sum + (item.toplamPuan || 0),
          0,
        ),
        ortalamaPuan:
          scoreBreakdown.length > 0
            ? Math.round(
              scoreBreakdown.reduce(
                (sum, item) => sum + (item.toplamPuan || 0),
                0,
              ) / scoreBreakdown.length,
            )
            : 0,
        onaylananGorev: scoreBreakdown.filter(
          item => item.durum === 'onaylandi',
        ).length,
        bekleyenGorev: scoreBreakdown.filter(item => item.durum === 'beklemede')
          .length,
      };

      // Apply pagination
      const page = parseInt(filters.page) || 1;
      const limit = parseInt(filters.limit) || 20;
      const skip = (page - 1) * limit;
      const toplamKayit = scoreBreakdown.length;
      const toplamSayfa = Math.ceil(toplamKayit / limit);
      const paginatedBreakdown = scoreBreakdown.slice(skip, skip + limit);

      console.log(
        `‚úÖ ${scoreBreakdown.length} puan breakdown hazƒ±rlandƒ±, ${paginatedBreakdown.length} g√∂steriliyor`,
      );

      res.json({
        scoreBreakdown: paginatedBreakdown,
        istatistikler: stats,
        sayfalama: {
          mevcutSayfa: page,
          toplamSayfa,
          toplamKayit,
          sayfaBoyutu: limit,
        },
      });
    } catch (error) {
      console.error('‚ùå Score breakdown hatasƒ±:', error.message);
      res.status(500).json({
        message: 'Sunucu hatasƒ±',
        error:
          process.env.NODE_ENV === 'development'
            ? error.message
            : 'Sunucu hatasƒ±',
      });
    }
  }

  /**
   * Get monthly score totals by category - Aylƒ±k toplam puanlarƒ± kategorize ederek getir
   */
  static async getMonthlyTotals(req, res) {
    try {
      const userId = req.user._id;
      const filters = req.query;

      console.log(
        `üìÖ ${req.user.ad} ${req.user.soyad} i√ßin aylƒ±k toplam puanlarƒ± getiriliyor...`,
      );

      // Get monthly totals data
      const monthlyTotals = await MyActivityHelpers.getMonthlyScoreTotals(
        userId,
        filters,
      );

      console.log(
        `‚úÖ ${monthlyTotals.donem.donemAdi} d√∂nemi toplam puanlarƒ± hazƒ±rlandƒ±`,
      );

      res.json({
        success: true,
        data: monthlyTotals,
        kullanici: {
          id: req.user._id,
          ad: req.user.ad,
          soyad: req.user.soyad,
        },
      });
    } catch (error) {
      console.error('‚ùå Aylƒ±k toplam puanlarƒ± hatasƒ±:', error.message);
      res.status(500).json({
        success: false,
        message: 'Sunucu hatasƒ±',
        error:
          process.env.NODE_ENV === 'development'
            ? error.message
            : 'Sunucu hatasƒ±',
      });
    }
  }

  /**
   * Get Quality Control criteria breakdown
   */
  static async getQualityCriteriaBreakdown(req, res) {
    try {
      const userId = req.user._id;
      const { month, year } = req.query;

      console.log('üî¨ Kalite kontrol madde bazlƒ± puanlar isteniyor:', {
        userId: userId.toString(),
        month,
        year,
      });

      // Tarih aralƒ±ƒüƒ±nƒ± belirle
      let dateFilter = {};
      if (month && year) {
        const startDate = new Date(parseInt(year), parseInt(month) - 1, 1);
        const endDate = new Date(
          parseInt(year),
          parseInt(month),
          0,
          23,
          59,
          59,
        );
        dateFilter = {
          $or: [
            {
              createdAt: {
                $gte: startDate,
                $lte: endDate,
              },
            },
            {
              degerlendirmeTarihi: {
                $gte: startDate,
                $lte: endDate,
              },
            },
          ],
        };
      } else {
        // Son 30 g√ºn
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - 30);
        dateFilter = {
          $or: [
            {
              createdAt: {
                $gte: startDate,
                $lte: endDate,
              },
            },
            {
              degerlendirmeTarihi: {
                $gte: startDate,
                $lte: endDate,
              },
            },
          ],
        };
      }

      // Kalite kontrol deƒüerlendirmelerini √ßek
      const qualityEvaluations = await QualityControlEvaluation.find({
        degerlendirilenKullanici: userId,
        ...dateFilter,
      })
        .populate('sablon', 'ad aciklama kriterler')
        .populate('degerlendirenKullanici', 'ad soyad')
        .sort({ degerlendirmeTarihi: -1, createdAt: -1 });

      console.log(
        `üìä ${qualityEvaluations.length} kalite kontrol deƒüerlendirmesi bulundu`,
      );

      // Madde bazƒ±nda puanlarƒ± topla
      const criteriaBreakdown = {};
      let totalEvaluations = 0;
      let totalScore = 0;
      let totalMaxScore = 0;

      qualityEvaluations.forEach(evaluation => {
        totalEvaluations++;

        if (evaluation.puanlamalar && evaluation.puanlamalar.length > 0) {
          evaluation.puanlamalar.forEach(puanlama => {
            const criteriaName = puanlama.maddeBaslik || 'Bilinmeyen Kriter';
            const score = puanlama.puan || 0;
            const maxScore = puanlama.maksimumPuan || 0;

            if (!criteriaBreakdown[criteriaName]) {
              criteriaBreakdown[criteriaName] = {
                criteriaName,
                totalScore: 0,
                totalMaxScore: 0,
                evaluationCount: 0,
                scores: [],
              };
            }

            criteriaBreakdown[criteriaName].totalScore += score;
            criteriaBreakdown[criteriaName].totalMaxScore += maxScore;
            criteriaBreakdown[criteriaName].evaluationCount++;
            criteriaBreakdown[criteriaName].scores.push({
              score,
              maxScore,
              evaluationId: evaluation._id,
              date: evaluation.degerlendirmeTarihi || evaluation.createdAt,
              evaluator: evaluation.degerlendirenKullanici
                ? `${evaluation.degerlendirenKullanici.ad} ${evaluation.degerlendirenKullanici.soyad}`
                : 'Bilinmeyen',
            });

            totalScore += score;
            totalMaxScore += maxScore;
          });
        }
      });

      // Sƒ±ralama - toplam puana g√∂re b√ºy√ºkten k√º√ß√ºƒüe
      const sortedCriteria = Object.values(criteriaBreakdown).sort(
        (a, b) => b.totalScore - a.totalScore,
      );

      // Her kriter i√ßin y√ºzdelik ba≈üarƒ± hesapla
      sortedCriteria.forEach(criteria => {
        criteria.successPercentage =
          criteria.totalMaxScore > 0
            ? Math.round((criteria.totalScore / criteria.totalMaxScore) * 100)
            : 0;
        criteria.averageScore =
          criteria.evaluationCount > 0
            ? Math.round(
              (criteria.totalScore / criteria.evaluationCount) * 100,
            ) / 100
            : 0;
      });

      const result = {
        criteria: sortedCriteria,
        summary: {
          totalEvaluations,
          totalCriteria: sortedCriteria.length,
          totalScore,
          totalMaxScore,
          overallSuccessPercentage:
            totalMaxScore > 0
              ? Math.round((totalScore / totalMaxScore) * 100)
              : 0,
          averageScore:
            totalEvaluations > 0
              ? Math.round((totalScore / totalEvaluations) * 100) / 100
              : 0,
        },
        dateRange: {
          month: month ? parseInt(month) : null,
          year: year ? parseInt(year) : null,
        },
      };

      console.log('‚úÖ Kalite kontrol madde bazlƒ± analiz tamamlandƒ±:', {
        toplamKriter: result.summary.totalCriteria,
        toplamDegerlendirme: result.summary.totalEvaluations,
        genelBasari: result.summary.overallSuccessPercentage,
      });

      res.json(result);
    } catch (error) {
      console.error('‚ùå Kalite kontrol kriter analizi hatasƒ±:', error.message);
      console.error('‚ùå Stack trace:', error.stack);
      res.status(500).json({
        message: 'Sunucu hatasƒ±',
        error:
          process.env.NODE_ENV === 'development'
            ? error.message
            : 'Sunucu hatasƒ±',
      });
    }
  }
}

module.exports = MyActivityController;
